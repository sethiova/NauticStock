const mysql = require("mysql2/promise");
const { db: dbConfig } = require("../config/config");

class DB {
  constructor(table) {
    this.table = table;
    this.selectFields = "*";
    this.joins = "";
    this.wheres = "1=1";
    this.order = "";
    this.group = "";
    this.limitVal = "";
    this.values = [];
    this.connection = null; // üëà AGREGAR PROPIEDAD
  }

  async connect() {
    try {
      if (!this.connection) {
        console.log('üîå Connecting to database...');
        this.connection = await mysql.createConnection(dbConfig);
        console.log('‚úÖ Database connected successfully');
      }
      return this.connection;
    } catch (err) {
      console.error('‚ùå Database connection failed:', err);
      throw err;
    }
  }

  // üëá M√âTODO MEJORADO: executeQuery -> execute (compatible con History.js)
  async execute(sql, params = []) {
    try {
      console.log('üìä Executing query:', sql);
      if (params.length > 0) {
        console.log('üìä With parameters:', params);
      }

      const conn = await this.connect();
      const [result] = await conn.execute(sql, params);
      
      console.log('‚úÖ Query executed successfully, rows:', result.length || result.affectedRows || 0);
      return result;
      
    } catch (error) {
      console.error("‚ùå Error en execute:", error);
      console.error("‚ùå Query was:", sql);
      console.error("‚ùå Parameters were:", params);
      
      // üëá NUEVO: Intentar reconectar si es error de conexi√≥n
      if (error.code === 'PROTOCOL_CONNECTION_LOST' || error.code === 'ECONNRESET') {
        console.log('üîÑ Connection lost, attempting to reconnect...');
        this.connection = null; // Reset connection
        const conn = await this.connect();
        const [result] = await conn.execute(sql, params);
        return result;
      }
      
      throw error;
    }
  }

  // üëá ALIAS PARA COMPATIBILIDAD (puedes usar ambos nombres)
  async executeQuery(sql, params = []) {
    return this.execute(sql, params);
  }

  select(fields = ["*"]) {
    this.selectFields = fields.join(", ");
    return this;
  }

  join(joinTable, onCondition, type = "INNER") {
    this.joins += ` ${type} JOIN ${joinTable} ON ${onCondition}`;
    return this;
  }

  where(conditions = []) {
    const clauses = conditions.map(([field, value, operator = "="]) => {
      if (operator.toUpperCase() === "IS" && value === null)
        return `${field} IS NULL`;
      if (operator.toUpperCase() === "IS" && value === "NOT NULL")
        return `${field} IS NOT NULL`;
      return `${field} ${operator} ?`;
    });
    this.wheres = clauses.join(" AND ");
    this.values = conditions
      .map((cond) => cond[1])
      .filter((v) => v !== "NOT NULL");
    return this;
  }

  orderBy(fields = []) {
    this.order = `ORDER BY ${fields
      .map(([field, dir]) => `${field} ${dir}`)
      .join(", ")}`;
    return this;
  }

  groupBy(fields = []) {
    this.group = `GROUP BY ${fields.join(", ")}`;
    return this;
  }

  limit(n) {
    this.limitVal = `LIMIT ${n}`;
    return this;
  }
  
  reset() {
    this.selectFields = '*';
    this.joins = '';
    this.wheres = '1=1';
    this.order = '';
    this.group = '';
    this.limitVal = '';
    this.values = [];
  }
  
  async get() {
    try {
      const sql = `SELECT ${this.selectFields} FROM ${this.table} ${this.joins} WHERE ${this.wheres} ${this.group} ${this.order} ${this.limitVal}`;
      const conn = await this.connect();
      const [rows] = await conn.execute(sql, this.values);
      return rows;
    } catch (error) {
      console.error("Error en DB.get():", error);
      throw error;
    } finally {
      this.reset();
    }
  }

  async insert(data) {
    try {
      const fields = Object.keys(data).join(", ");
      const placeholders = Object.keys(data)
        .map(() => "?")
        .join(", ");
      const values = Object.values(data);
      const sql = `INSERT INTO ${this.table} (${fields}) VALUES (${placeholders})`;
      
      console.log('üìù Inserting into:', this.table);
      const conn = await this.connect();
      const [result] = await conn.execute(sql, values);
      
      console.log('‚úÖ Insert successful, ID:', result.insertId);
      return result.insertId;
    } catch (error) {
      console.error("‚ùå Error en insert:", error);
      throw error;
    }
  }

  async update(data) {
    try {
      const fields = Object.keys(data)
        .map((key) => `${key} = ?`)
        .join(", ");
      const values = Object.values(data);
      const sql = `UPDATE ${this.table} SET ${fields} WHERE ${this.wheres}`;
      
      const conn = await this.connect();
      const [result] = await conn.execute(sql, [...values, ...this.values]);
      this.reset();
      
      console.log('‚úÖ Update successful, affected rows:', result.affectedRows);
      return result.affectedRows;
    } catch (error) {
      console.error("‚ùå Error en update:", error);
      throw error;
    }
  }

  async delete() {
    try {
      const sql = `DELETE FROM ${this.table} WHERE ${this.wheres}`;
      const conn = await this.connect();
      const [result] = await conn.execute(sql, this.values);
      this.reset();
      
      console.log('üóëÔ∏è Delete successful, affected rows:', result.affectedRows);
      return result.affectedRows;
    } catch (error) {
      console.error("‚ùå Error en delete:", error);
      throw error;
    }
  }

  // üëá NUEVO: M√©todo para cerrar conexi√≥n
  async close() {
    if (this.connection) {
      await this.connection.end();
      this.connection = null;
      console.log('üîå Database connection closed');
    }
  }
}

module.exports = DB;